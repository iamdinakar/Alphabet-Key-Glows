<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Glow Field — Touch / Drag / Keys</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0e14; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    .hud {
      position: fixed; inset: 0; pointer-events: none;
      font: 13px/1.35 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: rgba(255,255,255,.78);
    }
    .hint {
      position: absolute; left: 18px; top: 16px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(8,10,15,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      max-width: min(520px, calc(100vw - 36px));
      transition: opacity .6s ease, transform .6s ease;
    }
    .hint b { color: rgba(255,255,255,.92); font-weight: 650; }
    .hint .sub { opacity:.85; margin-top:4px; }
    .hint .kbd { display:inline-block; padding: 2px 8px; border-radius: 10px;
      background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.10);
      font-weight: 600; letter-spacing: .2px;
    }
    .hint.hide { opacity: 0; transform: translateY(-8px); }
    .corner {
      position:absolute; right:16px; bottom:14px;
      opacity:.55;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(8,10,15,.25);
      border: 1px solid rgba(255,255,255,.07);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select:none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div id="hint" class="hint">
    <div><b>Drag / touch</b> to paint light. <b>Press any key</b> to summon the letter as glowing trails.</div>
    <div class="sub">
      <span class="kbd">Space</span> clears • <span class="kbd">Enter</span> random letter • <span class="kbd">↑/↓</span> changes glow mood
    </div>
  </div>
  <div class="corner">Glow Field</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  const hint = document.getElementById('hint');

  // --- Resize ---------------------------------------------------------------
  let W=0, H=0, DPR=1;
  function resize() {
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);
    canvas.width = W; canvas.height = H;
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // --- Simplex Noise (2D) ---------------------------------------------------
  // Compact, fast enough for flow fields in a single file.
  class Simplex {
    constructor(seed=1) {
      this.p = new Uint8Array(256);
      for (let i=0;i<256;i++) this.p[i]=i;
      let s = seed >>> 0;
      const rand = () => (s = (s*1664525 + 1013904223)>>>0) / 4294967296;
      for (let i=255;i>0;i--) {
        const j = (rand()*(i+1))|0;
        const t = this.p[i]; this.p[i]=this.p[j]; this.p[j]=t;
      }
      this.perm = new Uint8Array(512);
      for (let i=0;i<512;i++) this.perm[i]=this.p[i & 255];
      this.grad3 = new Float32Array([
        1,1,  -1,1,  1,-1,  -1,-1,
        1,0,  -1,0,  1,0,   -1,0,
        0,1,  0,-1,  0,1,   0,-1
      ]);
      this.F2 = 0.5*(Math.sqrt(3)-1);
      this.G2 = (3-Math.sqrt(3))/6;
    }
    noise2D(xin, yin) {
      const perm = this.perm, g = this.grad3;
      const F2 = this.F2, G2 = this.G2;

      let n0=0, n1=0, n2=0;
      const s = (xin+yin)*F2;
      const i = Math.floor(xin+s);
      const j = Math.floor(yin+s);
      const t = (i+j)*G2;
      const X0 = i - t;
      const Y0 = j - t;
      const x0 = xin - X0;
      const y0 = yin - Y0;

      let i1, j1;
      if (x0 > y0) { i1=1; j1=0; } else { i1=0; j1=1; }

      const x1 = x0 - i1 + G2;
      const y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2*G2;
      const y2 = y0 - 1 + 2*G2;

      const ii = i & 255;
      const jj = j & 255;
      const gi0 = (perm[ii + perm[jj]] % 12) * 2;
      const gi1 = (perm[ii + i1 + perm[jj + j1]] % 12) * 2;
      const gi2 = (perm[ii + 1 + perm[jj + 1]] % 12) * 2;

      let t0 = 0.5 - x0*x0 - y0*y0;
      if (t0 >= 0) {
        t0 *= t0;
        n0 = t0*t0*(g[gi0]*x0 + g[gi0+1]*y0);
      }
      let t1 = 0.5 - x1*x1 - y1*y1;
      if (t1 >= 0) {
        t1 *= t1;
        n1 = t1*t1*(g[gi1]*x1 + g[gi1+1]*y1);
      }
      let t2 = 0.5 - x2*x2 - y2*y2;
      if (t2 >= 0) {
        t2 *= t2;
        n2 = t2*t2*(g[gi2]*x2 + g[gi2+1]*y2);
      }
      return 70*(n0 + n1 + n2); // ~[-1,1]
    }
  }
  const simplex = new Simplex((Math.random()*1e9)|0);

  // --- Palette / Mood -------------------------------------------------------
  const moods = [
    { base:[315, 50], flare:[55, 35], bg:"#0b0e14" },  // magenta + warm gold
    { base:[200, 35], flare:[320, 40], bg:"#070b12" }, // cyan + pink
    { base:[280, 45], flare:[120, 35], bg:"#070a10" }, // violet + green
    { base:[25,  40], flare:[205, 35], bg:"#090a0f" }, // ember + ice
  ];
  let moodIndex = 0;

  function bgFill() {
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = moods[moodIndex].bg;
    ctx.fillRect(0,0,W,H);
  }
  bgFill();

  // --- Particles ------------------------------------------------------------
  const MAX = Math.min(9000, (W*H)/(DPR*DPR) > 1.2e6 ? 7000 : 9000);
  const particles = [];
  const background = []; // subtle flow strokes
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  function makeParticle(x,y, hue, energy=1) {
    return {
      x,y,
      px:x, py:y,
      vx:0, vy:0,
      life:0,
      ttl: (40 + Math.random()*80) * (0.9 + energy*0.6),
      hue,
      a: 0.10 + Math.random()*0.18 + energy*0.16,
      w: (0.8 + Math.random()*1.6) * DPR * (0.9 + energy*0.6),
      spin: (Math.random()*2-1) * 0.8,
      jitter: 0.6 + Math.random()*1.2
    };
  }

  function addGlow(x,y, strength=1.0) {
    const m = moods[moodIndex];
    const h = (m.base[0] + (Math.random()*m.base[1])) % 360;
    const count = Math.floor(10 + 18*strength);
    for (let i=0;i<count;i++) {
      if (particles.length >= MAX) particles.shift();
      const r = (Math.random()**0.55) * (18*DPR*strength);
      const a = Math.random()*Math.PI*2;
      const px = x + Math.cos(a)*r;
      const py = y + Math.sin(a)*r;
      particles.push(makeParticle(px,py,h, strength));
    }
    // a few warm flares
    if (Math.random() < 0.55) {
      const hh = (m.flare[0] + Math.random()*m.flare[1]) % 360;
      const cc = Math.floor(3 + 7*strength);
      for (let i=0;i<cc;i++) {
        if (particles.length >= MAX) particles.shift();
        const r = (Math.random()**0.5) * (10*DPR*strength);
        const a = Math.random()*Math.PI*2;
        particles.push(makeParticle(x + Math.cos(a)*r, y + Math.sin(a)*r, hh, 1.15*strength));
      }
    }
  }

  // Subtle background “wind” lines
  function seedBackground() {
    background.length = 0;
    const n = Math.floor(420 * (W*H/(DPR*DPR) > 1.2e6 ? 1 : 1.1));
    for (let i=0;i<n;i++) {
      background.push({
        x: Math.random()*W,
        y: Math.random()*H,
        px:0, py:0,
        t: Math.random()*1000,
        hue: (moods[moodIndex].base[0] + Math.random()*moods[moodIndex].base[1]) % 360,
        a: 0.025 + Math.random()*0.035,
        w: (0.6 + Math.random()*1.2)*DPR
      });
    }
  }
  seedBackground();

  // --- Flow field -----------------------------------------------------------
  let time = 0;
  function flow(x,y,t) {
    // scale depends on screen to keep similar feel
    const s = 0.00135 * (DPR/1.5);
    const nx = x*s, ny = y*s;
    const n1 = simplex.noise2D(nx + t*0.06, ny - t*0.04);
    const n2 = simplex.noise2D(nx*1.9 - t*0.03, ny*1.9 + t*0.05);
    const ang = (n1*1.25 + n2*0.55) * Math.PI; // flow angle
    const spd = 0.55 + (0.45*(n2*0.5+0.5));
    return { ax: Math.cos(ang)*spd, ay: Math.sin(ang)*spd };
  }

  // --- Interactions ---------------------------------------------------------
  let interacted = false;
  const pointers = new Map(); // id -> {x,y,px,py}
  function toCanvas(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * DPR;
    const y = (e.clientY - rect.top) * DPR;
    return {x,y};
  }
  function hideHint() {
    if (!interacted) {
      interacted = true;
      hint.classList.add('hide');
    }
  }

  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    const p = toCanvas(e);
    pointers.set(e.pointerId, { x:p.x, y:p.y, px:p.x, py:p.y });
    hideHint();
    addGlow(p.x,p.y, 1.3);
  }, { passive:true });

  canvas.addEventListener('pointermove', (e) => {
    const s = pointers.get(e.pointerId);
    if (!s) return;
    const p = toCanvas(e);
    s.px = s.x; s.py = s.y;
    s.x = p.x; s.y = p.y;

    // spawn along segment for smoother trails
    const dx = s.x - s.px, dy = s.y - s.py;
    const dist = Math.hypot(dx,dy);
    const step = 10*DPR;
    const n = Math.max(1, Math.floor(dist/step));
    for (let i=0;i<n;i++) {
      const t = (i+1)/n;
      addGlow(s.px + dx*t, s.py + dy*t, clamp(dist/(40*DPR), 0.6, 1.8));
    }
    hideHint();
  }, { passive:true });

  canvas.addEventListener('pointerup', (e) => pointers.delete(e.pointerId), { passive:true });
  canvas.addEventListener('pointercancel', (e) => pointers.delete(e.pointerId), { passive:true });

  // --- Keyboard -> summon letter -------------------------------------------
  const glyph = document.createElement('canvas');
  const gctx = glyph.getContext('2d', { willReadFrequently: true });

  function spawnGlyph(ch) {
    hideHint();

    const size = Math.min(W, H) * 0.62;
    glyph.width = Math.max(1, (size|0));
    glyph.height = Math.max(1, (size|0));
    gctx.clearRect(0,0,glyph.width,glyph.height);

    // Draw big character
    const pad = size*0.08;
    const fontSize = size*0.78;
    gctx.fillStyle = "#fff";
    gctx.textAlign = "center";
    gctx.textBaseline = "middle";
    gctx.font = `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    gctx.fillText(ch, glyph.width/2, glyph.height/2 + size*0.02);

    // Sample pixels -> points
    const img = gctx.getImageData(0,0,glyph.width,glyph.height).data;
    const pts = [];
    const stride = Math.max(2, Math.floor(4 * (DPR/1.2))); // sampling density
    for (let y=0;y<glyph.height;y+=stride) {
      for (let x=0;x<glyph.width;x+=stride) {
        const a = img[(y*glyph.width + x)*4 + 3];
        if (a > 40) pts.push({x,y});
      }
    }
    // Emit from those points (random subset for performance)
    const cx = W/2 - glyph.width/2;
    const cy = H/2 - glyph.height/2;

    const m = moods[moodIndex];
    const baseHue = (m.base[0] + Math.random()*m.base[1]) % 360;
    const flareHue = (m.flare[0] + Math.random()*m.flare[1]) % 360;

    const budget = Math.min(2600, Math.max(900, (pts.length*0.12)|0));
    for (let i=0;i<budget;i++) {
      if (particles.length >= MAX) particles.shift();
      const p = pts[(Math.random()*pts.length)|0];
      const x = cx + p.x + (Math.random()*2-1)*2.2*DPR;
      const y = cy + p.y + (Math.random()*2-1)*2.2*DPR;
      const hue = (Math.random()<0.82) ? baseHue : flareHue;
      const prt = makeParticle(x,y,hue, 1.6);
      prt.ttl *= 1.25;
      prt.a  *= 1.35;
      prt.w  *= 1.2;
      // Start with a slight outward push so it feels “charged”
      const ang = Math.atan2(y - H/2, x - W/2) + (Math.random()*2-1)*0.25;
      const kick = (0.8 + Math.random()*1.2) * DPR;
      prt.vx += Math.cos(ang)*kick;
      prt.vy += Math.sin(ang)*kick;
      particles.push(prt);
    }

    // Small center burst
    addGlow(W/2, H/2, 2.2);
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (k === ' ') { // clear
      bgFill();
      particles.length = 0;
      return;
    }
    if (k === 'Enter') {
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      spawnGlyph(letters[(Math.random()*letters.length)|0]);
      return;
    }
    if (k === 'ArrowUp') { moodIndex = (moodIndex + 1) % moods.length; seedBackground(); return; }
    if (k === 'ArrowDown') { moodIndex = (moodIndex - 1 + moods.length) % moods.length; seedBackground(); return; }
    if (k && k.length === 1) spawnGlyph(k.toUpperCase());
  });

  // --- Render loop ----------------------------------------------------------
  function tick() {
    time += 1/60;

    // Gentle fade (keeps trails)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = `rgba(11,14,20,0.075)`;
    ctx.fillRect(0,0,W,H);

    // Background flow strokes (subtle)
    ctx.globalCompositeOperation = 'lighter';
    ctx.lineCap = 'round';
    for (let i=0;i<background.length;i++) {
      const b = background[i];
      b.px = b.x; b.py = b.y;
      const f = flow(b.x,b.y, b.t + time*0.25);
      b.x += f.ax * (28*DPR) * 0.04;
      b.y += f.ay * (28*DPR) * 0.04;
      if (b.x < -40 || b.x > W+40 || b.y < -40 || b.y > H+40) {
        b.x = Math.random()*W; b.y = Math.random()*H;
        b.px = b.x; b.py = b.y;
      }
      ctx.strokeStyle = `hsla(${b.hue}, 92%, 68%, ${b.a})`;
      ctx.lineWidth = b.w;
      ctx.beginPath();
      ctx.moveTo(b.px,b.py);
      ctx.lineTo(b.x,b.y);
      ctx.stroke();
    }

    // Foreground particles (bright glow)
    for (let i=particles.length-1;i>=0;i--) {
      const p = particles[i];
      p.life += 1;

      p.px = p.x; p.py = p.y;
      const f = flow(p.x, p.y, time*0.9);
      // Flow force + a little personal spin/jitter
      p.vx += f.ax * (0.9 + p.jitter*0.3) + Math.sin(time + p.spin)*0.015*DPR;
      p.vy += f.ay * (0.9 + p.jitter*0.3) + Math.cos(time + p.spin)*0.015*DPR;

      // Damp
      p.vx *= 0.93; p.vy *= 0.93;
      p.x += p.vx * (10*DPR) * 0.06;
      p.y += p.vy * (10*DPR) * 0.06;

      // Soft bounds wrap
      if (p.x < -30) p.x = W+30;
      if (p.x > W+30) p.x = -30;
      if (p.y < -30) p.y = H+30;
      if (p.y > H+30) p.y = -30;

      const t = p.life / p.ttl;
      const fade = (t < 0.8) ? 1 : (1 - (t-0.8)/0.2);
      const alpha = p.a * fade;

      // Draw: a bright core line + a soft aura
      ctx.strokeStyle = `hsla(${p.hue}, 95%, 66%, ${alpha})`;
      ctx.lineWidth = p.w;
      ctx.beginPath();
      ctx.moveTo(p.px, p.py);
      ctx.lineTo(p.x,  p.y);
      ctx.stroke();

      // Aura dot
      ctx.fillStyle = `hsla(${p.hue}, 95%, 72%, ${alpha*0.75})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.w*0.8, 0, Math.PI*2);
      ctx.fill();

      if (p.life >= p.ttl) particles.splice(i,1);
    }

    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Start with a small “L” vibe (like your reference) after 300ms
  setTimeout(() => spawnGlyph('L'), 300);
})();
</script>
</body>
</html>
